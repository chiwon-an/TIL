'''
1. 두 명의 일꾼이 있다. 꿀을 채취할 수 있는 벌통의 수 M이 주어질 때, 
       각각의 일꾼은 가로로 연속되도록 M개의 벌통을 선택하고, 선택한 벌통에서 꿀을 채취할 수 있다.
       단, 두 명의 일꾼이 선택한 벌통은 서로 겹치면 안 된다. 

2. 두 명의 일꾼은 선택한 벌통에서 꿀을 채취하여 용기에 담아야 한다.
       단, 서로 다른 벌통에서 채취한 꿀이 섞이게 되면 상품가치가 떨이지게 되므로, 하나의 벌통에서 채취한 꿀은 하나의 용기에 담아야 한다.
       하나의 벌통에서 꿀을 채취할 때, 일부분만 채취할 수 없고 벌통에 있는 모든 꿀을 한번에 채취해야 한다.
       두 일꾼이 채취할 수 있는 꿀의 최대 양은 C 이다.

3. 채취한 꿀은 시장에서 팔리게 된다. 이때 하나의 용기에 있는 꿀의 양이 많을수록 상품가치가 높아, 각 용기에 있는 꿀의 양의 제곱만큼의 수익이 생긴다.
       예를 들어 위 [Fig. 3]과 같이 꿀을 채취할 경우, 꿀의 양이 6, 1, 8인 세 개의 용기가 얻어지며 이때 수익의 합은, (6*6) + (1*1) + (8*8) = 36 + 1 + 64 = 101 이 된다.



벌통들의 크기 N과 벌통에 있는 꿀의 양에 대한 정보, 선택할 수 있는 벌통의 개수 M, 꿀을 채취할 수 있는 최대 양 C
이때 두 일꾼이 꿀을 채취하여 얻을 수 있는 수익의 합이 최대가 되는 경우를 찾고, 그 때의 최대 수익을 출력

(3 ≤ N ≤ 10) (1 ≤ M ≤ 5) (10 ≤ C ≤ 30) 
입력
T
N, M, C
ARR

풀이

1. 연속되는 두 개를 탐색 -> DFS -> 가로로 연속된 두 칸을 2개 뽑아줘야함. -> 겹치면 안되니까 VISITED행렬 사용 -> 

2. 최대 값이 C니까 두 개를 더해서 C가 되는지 확인 
    2-1. C가 넘는다? -> 큰 것만 리스트에 넣어주기

3. 각 리스트의 요소들을 제곱해서 더하기


'''

def dfs(idx_1):

    if len(lst_1) == 2 and len(lst_2) == 2:
        return
    
    if len(lst_1) == 2:
        lst_2.append(honey[idx_1])
        lst_2.append(honey[idx_1 + 1])
    
    for i in range(N):
        len_1.append(honey[idx_1])

